thorp's TODO's
==============
grade each loop's ss
    pose.secstruct()
    percent_helical = 100*ss.count('H') / len(ss)
ligand interface (example script D120)
analyze classes xyz_vector and xyz_matrix

functions
=========
pyrosetta
    manual
        http://graylab.jhu.edu/pyrosetta/downloads/documentation/PyRosetta_Manual.pdf
    relevant commands
        pose = Pose()
        pose_from_pdb(pose, 'the/file.pdb')
        print pose.residue(33)
        what is find_stub_transform() for?
    possibly useful
        rosetta.core.kinematics.AtomTree.jump
        rosetta.core.kinematics.AtomTree.get_stub_transform
        coord = pose.residue(740).atom('N').xyz()
        print coord.x
        pose2.jump(1).set_rotation(pose1.jump(1).get_rotation())
        pose2.jump(1).get_translation()
            "the contents of src/protocols/moves/RotateJumpAxisMover may be valuable. They show (well, not with enough comments) how to separate the two "stubs" (coordinate frames) out of the Jump, modify one of the Stubs, and then reassemble it into a Jump."
    recoding approach
        distance
            atomN = pose.residue(33).atom('N')
            NCbond = atomN.xyz() - atomC.xyz()
            print NCbond.norm()
        http://nipy.sourceforge.net/nibabel/generated/nibabel.eulerangles.html
        http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions
        http://www.lfd.uci.edu/~gohlke/code/transformations.py.html
        http://en.wikipedia.org/wiki/Euler_angles
    dig through source for good calls to use
        [pyrosetta]/demos/D010_Pose_structure.py
        * code block around line 100 shows how to judge loop composition (n% helical, etc)
    foldtree for docking
        DockingProtocol.setup_foldtree(pose)
        http://www.pyrosetta.org/screenshots
    export to pymol
        http://www.pyrosetta.org/pymol_mover-tutorial
prody
    fetchPDB('1GPL')
    atoms = parsePDB('1GPL.pdb.gz')

pymol
    get coordinates
        xyz = cmd.get_model('sele', 1).get_coord_list()
    show selected residues
        show spheres, sele (or res 52)
    import from pyrosetta
        http://www.pyrosetta.org/pymol_mover-tutorial
    ihome.cuhk.edu.hk ... pymol_tutorial.html
        color purple,ss h; color yellow,ss s; color green, ss ""
        mset 1 x120
        util.mroll 1,120 | util.mrock 1,120,180
        mplay
        mstop
http://jolecule.appspot.com/
    jump distances
- ac's?
- biopython?


algorithms
==========
Levenshtein automata: for string comparisonn, "nearness", to grade matches quickly
    http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata
    http://en.wikipedia.org/wiki/Levenshtein_automaton
Vantange-point tree: for finding points close to a vantage point on a 'tree'
    http://en.wikipedia.org/wiki/Vantage-point_tree
finding nearby residues
    models of hydrogen-bonding, Dunbrack side-chain, Ramachandran backbone energies
        must have an intelligent way of quickly finding nearest atoms/residues in cartesian

code
====
rough draft in python, use libraries liberally
mockup in go or c++, start coding own functions
final draft in go? go for blazing fast

optimizing
==========
http://docs.python.org/2/library/profile.html
centroid mode

parallelizing
=============
router as switch
PXE network booting

relevant books
==========================
Python for Data Analysis
Algorithms in a Nutshell
Version Control with Git
search books.google.com for "internal, atomtree" within "Computer Methods, Part 3". Seems like an in-depth explanation of Rosetta's 

data structures and file formats
================================
111 - Intro to CS
112 - Data Structures
214 - Systems Programming
